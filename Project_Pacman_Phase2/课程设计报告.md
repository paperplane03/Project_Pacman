# 课程设计报告
***
### 第一阶段（Phase1)：
---
1、基础工作（选择合适的GUI库）：

选择了Pygame库，找到了对应的教程并开始学习。  
Pygame库提供了易于使用的鼠标控制、画面处理、简易动画制作等功能，因此是制作这个类型和规模的程序的最佳选择。 

学习了Pygame的使用，并通过一些小的前置练习明白了如何处理点击、鼠标移动、键盘敲击，也学习了如何处理图片、发送定时信号、绘直线、矩形、圆弧等。  

---

2、界面制作：
首先决定了游戏界面的排版，采取了左侧为游戏内容（主要画面）、右侧为按钮的布局。

学习了本来吃豆人的地图排版，意识到地图可以被分割为格子，而吃豆人的地图大体上是网格状的离散布局。

按照这个理念，也为了简化地图的设计，决定用矩阵来生成地图。大体上，决定采用0代表空地，1代表墙壁。

思考地图的大小，决定采用16\*16的设计，每个格子为40\*40pixels，这样可以让画面总体出彩。
于是绘制了不同方向的吃豆人，从网上选择了合适的“墙壁”图片，设计出了最初的地图，同时绘制了网格（后来已去掉）。

在这个阶段采取的是“离散地图”，即吃豆人不是自动移动的，而是只有敲击键盘后才移动，类似于“棋类”游戏。同时，这时的“按钮”只是一个“事实上”的功能，就是敲击鼠标时检测其落点，如果落在给定的“区域”之中，则执行对应的函数。

随后加上了豆子和“吃豆子”的函数，最基本的游戏设计就制作完了。


<img src=".\报告图片\1.png" width="50%">

---

3、功能设计：

剩下的第一阶段部分是“功能”而不是“图像”，因此我想依次介绍我实现的功能，用文字而非代码。

首先是吃豆人的动画，在原版游戏中，吃豆人的嘴是“一张一合”的，于是我使用了一个定时的信号，定期刷新吃豆人的形态，即“张嘴”或“闭嘴”。

随后是地图生成。我选择结合了两种生成方式，即“游戏内生成”和“输入生成”。由于地图只是一个矩阵，因此地图的生成并不难。

再然后是随机地图，这是一个看上去不难，但实际上十分复杂的功能。我设计了一个参数，这个参数在总体上将控制地图的疏密（我的设置是这个参数是位于0-1之间的小数，数越小地图中墙越少）。

随机生成算法如下：
首先假设地图中无墙，随后依次遍历每个格子，首先看这个格子是不是关键格子（就是如果这个格子变成墙会不会让地图不连通），如果不是按概率把这个格子变成墙。

---
4、“连续”的吃豆人游戏：
第一阶段的最后一个部分是把吃豆人变成“连续”的游戏，但如何使吃豆人连续的跑动？
第一个想法就是让地图快速刷新，每次刷新时自动“更新”吃豆人的“实际位置”。但这样会让吃豆人转向变的极为困难，因为只有一瞬间吃豆人位于可以转向的位置，其他时候允许转弯必然会使得吃豆人和墙“穿模”。
如何使操作更为流畅困扰了我挺久。向同学请教经验时，他给我的“将实际坐标和动画坐标分开”的建议让我知道了如何改进。我因此设计了“实际坐标”和“动画坐标”，“实际坐标”是瞬间移动的，而“动画坐标”永远在从之前坐标走到实际坐标中，因此就有了动画效果，游戏变的“连续”了。

---
### 第一阶段-改（Phase1-Update）：

---
在第一阶段做完之后，做第二阶段之前，我对第一阶段的内容进行了较大的修改。应该说，整个第二阶段中我有约一半的时间是在进行第一阶段的更新，因此我将称之为“第一阶段改”。

---
1、重构代码：
第一阶段做完时，虽然功能均已经实现且没有bug，但所有代码都写在一个文件中，而且变量、变量作用范围均十分凌乱，于是我开始了漫长的重构。

本学期的课程中我学习了“面向对象程序设计风格”，因此我决定重构代码，将代码的架构调整。
因此我将程序拆分为了多个文件，每个文件各司其职。目前的作用是这样的（省略后缀py）：
MainLoad负责主运行，Control负责自动吃豆、鬼的追踪和吃豆人的智能（将在第二阶段、第三阶段投入使用），Agents定义了Pacman和Ghost的行为，Painting负责刷新画面，SrcLoad负责初始化游戏和加载图片的功能，Parameter中定义了一些重要的参数、Util中定义了Maps、Button、Directions这三个辅助类和对应的辅助函数。
我将本来只用零散的函数和变量定义的吃豆人、鬼、地图、按钮封装为了类，此中我感受到了“封装”的作用。比如说，设计吃豆人的行为的控制函数本来分散在各处，现在我可以集中至一个类；本来按钮的悬停、动画设计、位置需要一个按钮一个按钮分别控制，现在只要一行语句就可以创建一个新按钮。
同时，每个文件负责各自的功能，让代码更为清晰了，对应的功能（比如显示或者智能）可以分开编写。

---
2、改bug&小优化：
我处理掉了第一阶段中遗留的bug，也优化了某些小的方面，但总体上我并没有对功能上进行较大的优化。
以下是写于“readme”中的bug修改日志（划掉），不过其中这样“优化”让我对大作业有了更浓厚的兴趣。

<img src=".\报告图片\2.png" width="50%">

---
### 第二阶段（Phase2)：

---
1、代码模块的功能划分：
1) Agents.py中定义了两个类，Pacman类和Ghost类，每个类中详细的定义了对象可以做的行为，如吃豆人会吃豆子、吃胶囊变成无敌状态、移动、转向等；而鬼则会追击、逃跑、像原版一样，每个鬼还有自己的行动特色。
Pacman类有许多成员，其中有好几套坐标，这是为了和“连续动画”相一致；Ghost类也是。2) Painting.py中定义了repainting函数，这是GUI的核心函数，这个函数保证了游戏的画面刷新；以及辅助函数paintingbuttonborder，负责画按钮的边线
3) SrcLoad.py中定义了开始游戏会先加载的函数，分为input_file（从map.txt中提取默认地图），imageinit（提取图片），fontinit（加载字体）、initset（设置窗口等）、agentinit（初始化地图和对象）、setbutton（设置按钮）。
4) Util.py中定义了三个类：Map类、Directions类、Buttons类。Map类定义了地图的各个行为（比如重置地图、初始化地图、查询地图中每一格的值、查询地图的食物数量等）；Directions类是作为接口，规范化吃豆人和鬼的行为；Buttons类封装了按钮（显示按钮、点击按钮），使得可以“一行”创建一个新按钮，如Qt-C++和VB一般。
5) Parameter.py中定义了许多通用的参数，其中绝大部分不应该修改，不过仍然有两个可以修改的参数（比如说设定地图中墙壁密度的参数）。
6) MainLoad.py是地图的主文件，主要控制事件的while循环。游戏事件分为几种，如鼠标敲击、键盘敲击、鼠标移动、以及自定义信号，MainLoad中的main函数其实就是处理这些事件的。
7) Control.py是控制寻路的智能算法，具体将在下一部分进行阐述。

---

2.设计算法：
我设计了四个算法，主要是基于搜索、启发式搜索和动态规划算法。同时，在四个“成功”的算法之外，也遇到了几个遇到了反例的失败“寻路”算法。
在第二阶段，我主要学习了各种搜索算法，在CS188课程中也学习了入门的强化学习方法。不过第二阶段中我暂时没有写强化学习算法，而是打算在第三阶段中正式进行实现。
在叙述算法之前，我打算先阐述一下第二阶段的任务及其“变种”，从而更好的为接下来阐述算法做铺垫。
第二阶段的“基本”任务主要是：考虑只有豆子和吃豆人地图，设计将豆子可以尽快全部吃完的算法。
第二阶段的“变种”任务是：豆子很少（只有10颗左右）和只有一颗豆子的情况。
后两个任务是为前一个任务做铺垫的。
只有一颗豆子的情况和豆子很少的情况，是可以找到“绝对”的最优解的；但当豆子很多时，就只能选择“较优解”。但仍然有些思想是通用的。

---

Dynamic Programming（动态规划）：
先说DP算法，因为DP算法是一个确定的算法。DP算法基本只能在豆子小于15颗（如果性能优化后可以到20颗）时使用，用一个2进制数来表示吃掉某些豆子的算法。
比如假如有5颗豆子，状态就是五位二进制数。假设就取名为DP数组（个人习惯），DP[01100]即吃掉第三颗和第四颗豆子的最小代价，DP[10001]即吃掉第一颗和第五颗豆子的最小代价，自然DP[00000]=0，因为没吃掉豆子的代价自然为0。
现在根据吃豆子所在的位置，算出吃豆人走到某个豆子的最短路径dis，进行更新。
比如现在状态是DP[01100]，吃豆人位置在第三颗豆处，算出吃豆人到第一颗豆子的距离D后，就可以进行状态更新，DP[01101]=min{DP[01101],DP[01100]+D}。
当然DP数组是个二维数组，第二维数组的大小为2，分别存“最小距离”和对应的“位置”（但此处暂且省略第二个）。根据此就可以一步步更新到DP[11111]，值即为所有可能的路径中最小的。
因此，可知DP算法的空间复杂度为O(n*2^n)，经计算得时间复杂度为(n2*2^n)，在n过大的时候使用DP算法是不现实的，因此我设定为当豆子过多时DP算法不会执行。
DP算法只在”OneFood Map”和”Scarce”地图中有效。

---

搜索算法：
普通搜索算法主要是两种：DFS（深度优先搜索）和BFS（广度优先搜索）。
当豆子较少时，DFS/BFS也可以通过搜完所有的豆子来寻找最优解（遍历），但对于较多豆子时就不能如此做。因此为了解的通用性，剩下三种算法没选择全部搜完的方式，而是选择了另一种方式。
具体而言，在取舍之后，选择了这样的思路：设定某种代价，以最小化代价的前提找到“最优的下一颗豆子”，吃掉它，然后再做选择。
三种搜索算法都是如此，但是DFS/BFS和启发式搜索中设定的“代价”不一样。
DFS和BFS中的目标比较简单，就是“第一颗找到的豆子”，因此算法可以简化为“找到第一颗没吃掉豆子，吃掉它，然后继续找，直到吃完为止”，这两种搜索的区别在于找到最近豆子的方法，是深搜，还是广搜。经检验，绝大部分情况下广搜优于深搜。（豆子极少时例外）
因为广搜保证找到的一定是最近的豆子，而深搜有可能找到相当远的一颗豆子（但在搜索过程中，它确实第一颗被找到的）

---

启发式搜索：
启发式搜索中的代价函数是“所有豆子”到某个点的曼哈顿距离之和，因此吃的下一颗豆子不一定是最近的，但吃掉这颗豆子后可以让位置和剩下所有位置之和较近。
因此我设计这种算法，希望在另一种程度上能让吃豆人有一定的“大局观”。

---


启发式搜索之前：
关于这个启发式搜索，是存在一个废案的，就是按照“所有豆子到某个点的曼哈顿距离之和”来决定每一次怎么走（而不是下一个吃什么豆子），但这样的算法存在死胡同，考虑如下情况。

这种情况下，黄色位置的吃豆人到三颗豆子的总曼哈顿距离是6，但吃豆人一旦走了一格（无论哪个方向），总曼哈顿距离就变成了7，也因此吃豆人会“徘徊”，它没法跳出这样的“局部坑”。
因此这个算法是失败的。


---

可能的改进1：
由于墙的存在，所以曼哈顿距离并不一定是实际距离，任意两点的实际距离都可以在开始通过Floyd算法算出，或许这是可以改进的一个点，但当豆子较多时，Floyd的O(n^3)复杂度将影响游戏运行。

---

可能的改进2：
对于这种不必求“最优解”的问题，或许一个改进是采取比较著名的启发式算法，如“模拟退火算法"等，但由于这个阶段我在学习强化学习算法，所以就没来得及写这种算法。

---

地图设计：
为了更好的设计并且对算法进行细节上的优化，我设计了如下几种地图。
Default：基本地图，但未采取吃豆人游戏中的地图，而是设计了网格地图。
Random：随机地图（一定连通），地图中墙的数量可以通过参数控制。
OneFood：随机地图，只有一个食物
Default Scarce：基本地图，只有零碎的食物
Random Scarce：随机地图，只有零碎的食物
~~Dust2：看CSGO比赛上头的产物，模拟了Dust2的地图，作为彩蛋，并没有在Phase2的阶段中将这个地图丢进按钮中~~

（大雾）
<img src=".\报告图片\3.png" width="50%">

---
算法效率统计：
首先来看一张表格（表格内数字是吃完所有豆子所需的步数，随机地图/稀少食物自然受随机性所影响，因此除了确定的地图外，都只有统计结果）
| Algorithm	| Dynamic Programming	| BFS	| DFS	| Heuristic |
|:---------:|:-------:|:-------:|:--------:|:-----------:|
|Default Scarce|About 57|About 63|About 80|About 70|
|Random Scarce|About 62|About 66|About 85|About 72|
|OneFood Map|Optimal|Optimal|Optimal|Optimal|
|Default Map|/|	200(Exact)|	337(Exact)|	214(Exact)|
|Random Map|/|270-300|500-1500|350-450|
|(Bonus)Dust2 Map|/|192(Exact)|658(Exact)|214(Exact)|

这是不同算法在不同地图中的表现，基本为DP\<BFS\<=Heuristic\<\<DFS（当然，DP必然是最优解，但DP自然有其限制）
DFS随机性影响很大而且普遍性能最弱，因为DFS找到下一个豆子是很大程度上“不确定的”，而BFS略优于Heuristic说明当前设计的启发函数还不够优秀。
在稀少豆子的地图中，各种算法的差距不大，但豆子更多的时候，差距就变的大了起来。由于此时想找到最优解几乎不可能，只能想办法让AI有更优的“大局观”和“智能”

---

### 第二阶段总结

第二阶段的重点在于拆分问题，并且实现“搜索并尽快的吃掉所有的豆子”。
因此，在学习了第二阶段的参考资料"Project-CS188"之后，我将问题拆分成两个变种，在实现这两个变种的同时渐渐地实现原本的问题。
第一个变种是“只有一个豆子”，这时可以通过搜索（启发式搜索）、单源最短路径、动态规划来解决这个问题。
第二个变种是“有数个的豆子”，此时可以通过搜索（启发式搜索）、动态规划来找到最优解，也可以用“一个豆子一个豆子”的搜索来找到较优解。
随后是原本的问题“有许多的豆子”，此时想找到最优解已经不太现实（接近旅行商问题），因此主要是通过贪心搜索和启发式搜索找到较优解。

在这个阶段中，我一方面是优化了程序的架构，使得程序可以较好地兼容各种不同的搜索算法（有的算法是离线的，在最初时就可以全部算好；有的算法是在线的，是一步步考虑的，要兼容这两种算法需要较好的程序架构）。
另一方面，在这个阶段我在试图采用各种不同的非人工智能算法来实现“搜索的智能”，同时也在学习CS188课程和强化学习算法。不同的搜索算法确实有不同的表现，我在程序设计的过程中深有体会。

第二阶段的设计内容就到这里了，我希望在第三阶段可以圆满的完成这个游戏、这个大作业，也可以入门人工智能算法和各类算法。
除了作业本身学到的“智能”知识之外，这样一个“设计游戏”（逐渐创建新功能、运行、调试bug）的过程对我程序设计水平也是大有帮助的。
第三阶段再见(\*^▽\^\*)~